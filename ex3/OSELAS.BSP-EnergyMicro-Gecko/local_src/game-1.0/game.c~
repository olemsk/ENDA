#include <stdio.h>
#include <stdlib.h>
#include <linux/fb.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <stdint.h>   
#include <stdbool.h>  
//#include "efm32gg.h"

struct fb_var_screeninfo screen_info;


// int screensize_bytes;

void *input_value;
time_t t;


int main(int argc, char *argv[])
{	
	uint16_t *screen;
	struct fb_copyarea rect;
	rect.dx=0;
	rect.dy=0;
	rect.width=320;
	rect.height=240;
	///////////////////////////// writing to framebuffer /////////////////////////////
	int descr = open("/dev/fb0", O_RDWR);
	

	printf("descr: %d\n", descr);
	if(descr == -1)
	{	
		printf("open fail1\n");
		exit(1);
	}	
	
	/*
	int did = open("/dev/gamepad", O_RDONLY);
	if(did == -1)
	{	
		printf("open fail2\n");
		exit(1);
	}	
	
	while(1)
	{

	ssize_t vasar = read(did, input_value, 1);
		printf("%d \n", (int)(*((char*)input_value)-'0'));
	
		sleep(2);

	}
	*/
	
	
	

	
	
	screen = (uint16_t*)mmap(NULL, 320*240*2, PROT_READ|PROT_WRITE, MAP_SHARED, descr, 0);
	if((void*)screen == MAP_FAILED)
	{
		printf("Screen mapping failed\n");
		exit(1);
	}	


	//refresh_screen(descr, screen);

	
	//make_obstacle(descr,screen, y_start_maker(t));
	//test_screen(descr, screen);
	fake_game(descr,screen);
	//ioctl(descr, 0x4680, &rect);

	
	
	close(descr);
	

	printf("chiken\n");

	exit(EXIT_SUCCESS);
}

void refresh_screen(int descr, uint16_t *screen){
	int i;

	struct fb_copyarea rect;
	rect.dx=0;
	rect.dy=0;
	rect.width=320;
	rect.height=240;

	for(i = 0; i < 320*240; i++){
		screen[i] = 0;
		
	}
	//ioctl(descr, 0x4680, &rect);
}

void make_line(int descr, uint16_t *screen, int pos, uint16_t color, int y_start)
{	

	int gap=50;
	int y;
	
	
	for (y = 0; y < 240; y++)
	{
	if( y<y_start+gap && y>y_start)
	{
		screen[320*y + pos] = 0;
	}
	else
	{
		screen[320*y + pos] = color;
	}
	}
		
}


void make_obstacle(int descr, uint16_t *screen, int y_start, int pos)
{
	
	
	
	uint16_t colors[]={0xff00, 0x0ff0, 0x00ff};
	int i=0;
	for(i=0;i<3;i++)
	{
		
		make_line(descr, screen, pos+i*4, colors[i], y_start);
		
	
	}
		

}


int y_start_maker(time_t *t)
{
srand((unsigned) time(t));
return rand() %160;
}


void test_screen(int descr, uint16_t *screen)
{

	time_t temp;
	int ystart = y_start_maker(temp); 
	int x=315;
	for(x =305; x > 0; x--)
	{
		refresh_screen(descr, screen);
		make_obstacle(descr, screen, ystart, x);
		
	
	} 
}


void fake_game(int descr, uint16_t *screen)
{
	time_t temp;
	int x, offset=80;
	
	struct fb_copyarea rect;
	rect.dx=0;
	rect.dy=0;
	rect.width=320;
	rect.height=240;
	
	
	
	while(1)
	{
		
		int ystart1 = y_start_maker(temp);
		
		usleep(300);
		
		int ystart2 = y_start_maker(temp); 
		
	for(x =305; x > 0; x--)
	{	
	
		
	
	
		
		refresh_screen(descr, screen);
		make_obstacle(descr, screen, ystart1, x);
		if(x+offset < 315)
		{
		make_obstacle(descr, screen, ystart2, x+offset);
		}
		ioctl(descr, 0x4680, &rect);
	
	} 
	
	
	}

}

