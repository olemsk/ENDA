#include <stdio.h>
#include <stdlib.h>
#include <linux/fb.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <stdint.h>   
#include <stdbool.h>  
#include <efm32gg.h>

struct fb_var_screeninfo screen_info;


// int screensize_bytes;

char input_values[]={0,0,0,0,0,0,0,0};

int main(int argc, char *argv[])
{	
	uint16_t *screen;
	struct fb_copyarea rect;
	rect.dx=0;
	rect.dy=0;
	rect.width=320;
	rect.height=240;
	///////////////////////////// writing to framebuffer /////////////////////////////
	int descr = open("/dev/fb0", O_RDWR);
	

	printf("descr: %d\n", descr);
	if(descr == -1)
	{	
		printf("open fail1\n");
		exit(1);
	}	
	/*
	int did = open("/dev/gamepad", O_RDONLY);
	if(did == -1)
	{	
		printf("open fail2\n");
		exit(1);
	}	
	

	while(1)
	{

	ssize_t vasar = read(did, input_values, 8);
		printf("%d \n", input_values);
	


	}

	*/
	//int descr1 = open("/dev/driver-gamepad", O_RDONLY);
	
	//ssize_t temp_ c=read(descr1, &buffer, 1);
	//ssize_t temp_d=write(descr1, &awda, 1);
	

	//screensize_bytes = (320*240)*screen_info.bits_per_pixel/8;
	int y;
	int x;
	screen = (uint16_t*)mmap(NULL, 320*240*2, PROT_READ|PROT_WRITE, MAP_SHARED, descr, 0);
	if((void*)screen == MAP_FAILED)
	{
		printf("Screen mapping failed\n");
		exit(1);
	}	

	//refresh_screen(descr, screen);

	for( y = 150; y < 220; y++)
	{	
		for( x = 200; x < 250; x++)
		{
			screen[340*y + x] = 0x00ff; 
			
		}	
	}

	ioctl(descr, 0x4680, &rect);

	//refresh_screen(descr, screen);

	
	//int temp_a=close(descr);
	close(descr);
	//int temp_b=close(descr1);

	printf("chiken\n");

	exit(EXIT_SUCCESS);
}

void refresh_screen(int descr, uint16_t *screen){
	int i;

	struct fb_copyarea rect;
	rect.dx=0;
	rect.dy=0;
	rect.width=320;
	rect.height=240;

	for(i = 0; i < 320*240; i++){
		screen[i] = 0;
		//printf("pikselnr %d har verdien: %d \n", i, screen[i]); 
	}
	ioctl(descr, 0x4680, &rect);
}
